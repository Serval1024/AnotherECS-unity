<#META GENERATOR = AnotherECS.Unity.Jobs.Generator.JobBagGenerator FILENAME = JobBag.cs N = 8#>

// <auto-generated>
// This source code was auto-generated by JobBagGenerator.cs
// </auto-generated>

using System.Runtime.CompilerServices;
using Unity.Collections;
using EntityId = System.UInt32;

namespace AnotherECS.Unity.Jobs
{
<#ARRAY [0..2]#>
---<#ARRAY [0..STRUCT_COUNT]#>
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<#R:TAG#><<#ARRAY [0..GENERIC_COUNT]#>T<#INDEX2#><#SEPARATOR1:,#><#END#>> : IJobBag
------<#ARRAY [0..GENERIC_COUNT]#>
        where T<#INDEX2#> : unmanaged
------<#END#>
    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

------<#ARRAY [0..GENERIC_COUNT]#>
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse<#INDEX2#>;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version<#INDEX2#>;
        [NativeDisableParallelForRestriction]<#RW:READ_ONLY:TAG#> internal NativeArray<T<#INDEX2#>> component<#INDEX2#>;
------<#END#>
        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

------<#ARRAY [0..GENERIC_COUNT]#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT<#INDEX2#>(int index)
            => sparse<#INDEX2#>[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T<#INDEX2#> ReadT<#INDEX2#>(int index)
            => component<#INDEX2#>[GetComponentIndex<#INDEX2#>(index)];
------<#IF RW:READ_ONLY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T<#INDEX2#> GetT<#INDEX2#>(int index)
            => ref component<#INDEX2#>.GetRef(GetComponentIndex<#INDEX2#>(index));
------<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT<#INDEX2#>(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version<#INDEX2#>.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T<#INDEX2#>));
            }
#endif
            return version<#INDEX2#>[GetComponentIndex<#INDEX2#>(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex<#INDEX2#>(int index)
            => sparse<#INDEX2#>[GetEntity(index)];
------<#END#>

------<#ARRAY [0..GENERIC_COUNT]#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT<#INDEX2#>(uint index)
            => sparse<#INDEX2#>[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T<#INDEX2#> ReadT<#INDEX2#>(uint index)
            => component<#INDEX2#>[GetComponentIndex<#INDEX2#>(index)];
------<#IF RW:READ_ONLY#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T<#INDEX2#> GetT<#INDEX2#>(uint index)
            => ref component<#INDEX2#>.GetRef(GetComponentIndex<#INDEX2#>(index));
------<#END#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT<#INDEX2#>(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version<#INDEX2#>.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T<#INDEX2#>));
            }
#endif
            return version<#INDEX2#>[GetComponentIndex<#INDEX2#>(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex<#INDEX2#>(uint index)
            => sparse<#INDEX2#>[GetEntity(index)];
------<#END#>
    }
---<#END#>
<#END#>
}
