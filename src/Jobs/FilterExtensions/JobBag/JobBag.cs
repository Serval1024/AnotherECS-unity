//GENERATOR = AnotherECS.Unity.Jobs.Generator.JobBagGenerator FILENAME = JobBag.cs N = 8

// <auto-generated>
// This source code was auto-generated by JobBagGenerator.cs
// </auto-generated>

using System.Runtime.CompilerServices;
using Unity.Collections;
using EntityId = System.UInt32;

namespace AnotherECS.Unity.Jobs
{
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0> : IJobBag
        where T0 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2, T3> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T3> component3;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2, T3, T4> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T4> component4;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2, T3, T4, T5> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T5> component5;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2, T3, T4, T5, T6> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged
        where T6 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T5> component5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T6> component6;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(int index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(int index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(int index)
            => sparse6[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(uint index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(uint index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(uint index)
            => sparse6[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBagR<T0, T1, T2, T3, T4, T5, T6, T7> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged
        where T6 : unmanaged
        where T7 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T5> component5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T6> component6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse7;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version7;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<T7> component7;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(int index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(int index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(int index)
            => sparse6[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT7(int index)
            => sparse7[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T7 ReadT7(int index)
            => component7[GetComponentIndex7(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT7(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version7.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T7));
            }
#endif
            return version7[GetComponentIndex7(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex7(int index)
            => sparse7[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(uint index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(uint index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(uint index)
            => sparse6[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT7(uint index)
            => sparse7[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T7 ReadT7(uint index)
            => component7[GetComponentIndex7(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT7(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version7.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T7));
            }
#endif
            return version7[GetComponentIndex7(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex7(uint index)
            => sparse7[GetEntity(index)];

    }

#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0> : IJobBag
        where T0 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2, T3> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction] internal NativeArray<T3> component3;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(int index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(uint index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2, T3, T4> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction] internal NativeArray<T4> component4;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(int index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(int index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(uint index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(uint index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2, T3, T4, T5> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction] internal NativeArray<T5> component5;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(int index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(int index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(int index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(uint index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(uint index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(uint index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2, T3, T4, T5, T6> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged
        where T6 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction] internal NativeArray<T5> component5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version6;
        [NativeDisableParallelForRestriction] internal NativeArray<T6> component6;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(int index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(int index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(int index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(int index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(int index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T6 GetT6(int index)
            => ref component6.GetRef(GetComponentIndex6(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(int index)
            => sparse6[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(uint index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(uint index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(uint index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(uint index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(uint index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T6 GetT6(uint index)
            => ref component6.GetRef(GetComponentIndex6(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(uint index)
            => sparse6[GetEntity(index)];

    }
#if ENABLE_IL2CPP
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.NullChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.ArrayBoundsChecks, false)]
    [Unity.IL2CPP.CompilerServices.Il2CppSetOption (Option.DivideByZeroChecks, false)]
#endif
    public unsafe struct JobBag<T0, T1, T2, T3, T4, T5, T6, T7> : IJobBag
        where T0 : unmanaged
        where T1 : unmanaged
        where T2 : unmanaged
        where T3 : unmanaged
        where T4 : unmanaged
        where T5 : unmanaged
        where T6 : unmanaged
        where T7 : unmanaged

    {
        internal int count;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<EntityId> indexes;

        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version0;
        [NativeDisableParallelForRestriction] internal NativeArray<T0> component0;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version1;
        [NativeDisableParallelForRestriction] internal NativeArray<T1> component1;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version2;
        [NativeDisableParallelForRestriction] internal NativeArray<T2> component2;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version3;
        [NativeDisableParallelForRestriction] internal NativeArray<T3> component3;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version4;
        [NativeDisableParallelForRestriction] internal NativeArray<T4> component4;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version5;
        [NativeDisableParallelForRestriction] internal NativeArray<T5> component5;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version6;
        [NativeDisableParallelForRestriction] internal NativeArray<T6> component6;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<ushort> sparse7;
        [NativeDisableParallelForRestriction][ReadOnly] internal NativeArray<uint> version7;
        [NativeDisableParallelForRestriction] internal NativeArray<T7> component7;

        public int Count
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => count;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void BeginForEachIndex(int chunkIndex) { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EndForEachIndex() { }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(int index)
           => (int)indexes[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetEntity(uint index)
           => (int)indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public EntityId GetEntityId(uint index)
           => indexes[(int)index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(int index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(int index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(int index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(int index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(int index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(int index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(int index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(int index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(int index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(int index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(int index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(int index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(int index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(int index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(int index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(int index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(int index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(int index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(int index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(int index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(int index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(int index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(int index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(int index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(int index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(int index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T6 GetT6(int index)
            => ref component6.GetRef(GetComponentIndex6(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(int index)
            => sparse6[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT7(int index)
            => sparse7[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T7 ReadT7(int index)
            => component7[GetComponentIndex7(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T7 GetT7(int index)
            => ref component7.GetRef(GetComponentIndex7(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT7(int index)
        {
#if !ANOTHERECS_RELEASE
            if (version7.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T7));
            }
#endif
            return version7[GetComponentIndex7(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex7(int index)
            => sparse7[GetEntity(index)];


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT0(uint index)
            => sparse0[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T0 ReadT0(uint index)
            => component0[GetComponentIndex0(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T0 GetT0(uint index)
            => ref component0.GetRef(GetComponentIndex0(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT0(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version0.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T0));
            }
#endif
            return version0[GetComponentIndex0(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex0(uint index)
            => sparse0[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT1(uint index)
            => sparse1[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T1 ReadT1(uint index)
            => component1[GetComponentIndex1(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T1 GetT1(uint index)
            => ref component1.GetRef(GetComponentIndex1(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT1(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version1.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T1));
            }
#endif
            return version1[GetComponentIndex1(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex1(uint index)
            => sparse1[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT2(uint index)
            => sparse2[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T2 ReadT2(uint index)
            => component2[GetComponentIndex2(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T2 GetT2(uint index)
            => ref component2.GetRef(GetComponentIndex2(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT2(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version2.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T2));
            }
#endif
            return version2[GetComponentIndex2(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex2(uint index)
            => sparse2[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT3(uint index)
            => sparse3[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T3 ReadT3(uint index)
            => component3[GetComponentIndex3(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T3 GetT3(uint index)
            => ref component3.GetRef(GetComponentIndex3(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT3(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version3.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T3));
            }
#endif
            return version3[GetComponentIndex3(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex3(uint index)
            => sparse3[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT4(uint index)
            => sparse4[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T4 ReadT4(uint index)
            => component4[GetComponentIndex4(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T4 GetT4(uint index)
            => ref component4.GetRef(GetComponentIndex4(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT4(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version4.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T4));
            }
#endif
            return version4[GetComponentIndex4(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex4(uint index)
            => sparse4[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT5(uint index)
            => sparse5[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T5 ReadT5(uint index)
            => component5[GetComponentIndex5(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T5 GetT5(uint index)
            => ref component5.GetRef(GetComponentIndex5(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT5(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version5.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T5));
            }
#endif
            return version5[GetComponentIndex5(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex5(uint index)
            => sparse5[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT6(uint index)
            => sparse6[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T6 ReadT6(uint index)
            => component6[GetComponentIndex6(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T6 GetT6(uint index)
            => ref component6.GetRef(GetComponentIndex6(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT6(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version6.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T6));
            }
#endif
            return version6[GetComponentIndex6(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex6(uint index)
            => sparse6[GetEntity(index)];
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool HasT7(uint index)
            => sparse7[GetEntity(index)] != 0;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T7 ReadT7(uint index)
            => component7[GetComponentIndex7(index)];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T7 GetT7(uint index)
            => ref component7.GetRef(GetComponentIndex7(index));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint ReadVersionT7(uint index)
        {
#if !ANOTHERECS_RELEASE
            if (version7.Length == 0)
            {
                throw new AnotherECS.Unity.Jobs.Exceptions.ComponentNotSupportVersionException(typeof(T7));
            }
#endif
            return version7[GetComponentIndex7(index)];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private ushort GetComponentIndex7(uint index)
            => sparse7[GetEntity(index)];

    }


}
